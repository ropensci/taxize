% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_gbifid.R
\name{get_gbif}
\alias{get_gbif}
\alias{get_gbifid}
\alias{as.gbif}
\alias{as.gbif.txid}
\alias{as.gbif.character}
\alias{as.gbif.list}
\alias{as.gbif.numeric}
\alias{as.gbif.data.frame}
\alias{as.data.frame.txid}
\alias{get_gbif_}
\alias{get_gbifid_}
\title{Get the GBIF backbone taxon ID from taxonomic names.}
\usage{
get_gbif(
  sci,
  ask = TRUE,
  messages = TRUE,
  rows = NA,
  phylum = NULL,
  class = NULL,
  order = NULL,
  family = NULL,
  rank = NULL,
  method = "backbone",
  sciname = NULL,
  ...
)

get_gbifid(...)

as.gbif(x, check = FALSE)

\method{as.gbif}{txid}(x, check = FALSE)

\method{as.gbif}{character}(x, check = TRUE)

\method{as.gbif}{list}(x, check = TRUE)

\method{as.gbif}{numeric}(x, check = TRUE)

\method{as.gbif}{data.frame}(x, check = TRUE)

\method{as.data.frame}{txid}(x, ...)

get_gbif_(sci, messages = TRUE, rows = NA, method = "backbone", sciname = NULL)

get_gbifid_(...)
}
\arguments{
\item{sci}{(character) one or more scientific names. Or, a \code{taxon_state}
object (see \link{taxon-state})}

\item{ask}{logical; should get_gbif be run in interactive mode?
If TRUE and more than one ID is found for the species, the user is asked for
input. If FALSE NA is returned for multiple matches.}

\item{messages}{logical; If TRUE the actual taxon queried is printed on the console.}

\item{rows}{numeric; Any number from 1 to infinity. If the default NA, all rows are considered.
Note that this function still only gives back a gbifid class object with one to many identifiers.
See \code{\link[=get_gbif_]{get_gbif_()}} to get back all, or a subset, of the raw data that you are
presented during the ask process.}

\item{phylum}{(character) A phylum (aka division) name. Optional. See \code{Filtering}
below.}

\item{class}{(character) A class name. Optional. See \code{Filtering} below.}

\item{order}{(character) An order name. Optional. See \code{Filtering} below.}

\item{family}{(character) A family name. Optional. See \code{Filtering} below.}

\item{rank}{(character) A taxonomic rank name. See \link{rank_ref} for possible
options. Though note that some data sources use atypical ranks, so inspect the
data itself for options. Optional. See \code{Filtering} below.}

\item{method}{(character) one of "backbone" or "lookup". See Details.}

\item{sciname}{Deprecated, see \code{sci}}

\item{...}{Ignored}

\item{x}{Input to \code{\link[=as.gbif]{as.gbif()}}}

\item{check}{logical; Check if ID matches any existing on the DB, only used in
\code{\link[=as.gbif]{as.gbif()}}}
}
\value{
A vector of taxonomic identifiers as an S3 class.
If a taxon is not found an \code{NA} is given. If more than one identifier
is found the function asks for user input if \code{ask = TRUE}, otherwise
returns \code{NA}. If \code{ask=FALSE} and \code{rows} does not equal
\code{NA}, then a data.frame is given back, but not of the uid class, which
you can't pass on to other functions as you normally can.

See \code{\link{get_id_details}} for further details including
attributes and exceptions
}
\description{
Get the GBIF backbone taxon ID from taxonomic names.
}
\details{
Internally in this function we use a function to search GBIF's taxonomy,
and if we find an exact match we return the ID for that match. If there isn't an
exact match we return the options to you to pick from.
}
\section{method parameter}{

"backbone" uses the \verb{/species/match} GBIF API route, matching against their
backbone taxonomy. We turn on fuzzy matching by default, as the search without
fuzzy against backbone is quite narrow. "lookup" uses the \verb{/species/search}
GBIF API route, doing a full text search of name usages covering scientific
and vernacular named, species descriptions, distributions and the entire
classification.
}

\section{Filtering}{

The parameters \code{phylum}, \code{class}, \code{order}, \code{family}, and \code{rank} are not used
in the search to the data provider, but are used in filtering the data down
to a subset that is closer to the target you want.  For all these parameters,
you can use regex strings since we use \code{\link[=grep]{grep()}} internally to match.
Filtering narrows down to the set that matches your query, and removes the rest.
}

\examples{
\dontrun{
get_gbif(sci='Poa annua')
get_gbif(sci='Pinus contorta')
get_gbif(sci='Puma concolor')

#lots of queries
spp <- names_list("species", 10)
res <- get_gbif(spp)
res
xx <- taxon_last()
xx

# multiple names
x <- get_gbif(c("Poa annua", "Pinus contorta", "adf"))
x
as.data.frame(x) # returns a tibble
nms <- c("Poa", "Abies magnifica", "Pinaceae", "Pinopsida", "Eukaryota", "Abies")
w <- get_gbif(nms)
w
as.data.frame(w)
class(w)

# extract parts (maintains the txid/taxa_taxon class)
library(taxa)
tax_rank(w)
as.character(tax_rank(w))
tax_id(w)
as.character(tax_id(w))
tax_name(w)
as.character(tax_name(w))

# subset (maintains the txid/taxa_taxon class)
w[1]
w[1:3]
w[tax_rank(w) > 'genus']
names(w) <- letters[1:6]
w
w[c('b', 'c')]

## convert to taxonomy object
taxonomy(w)


# specify rows to limit choices available
get_gbif(sci='Pinus')
get_gbif(sci='Pinus', rows=10)
get_gbif(sci='Pinus', rows=1:3)

# When not found, NA given
get_gbif(sci="uaudnadndj")
get_gbif(c("Chironomus riparius", "uaudnadndj"))

# Narrow down results to a division or rank, or both
## Satyrium example
### Results w/o narrowing
get_gbif("Satyrium")
### w/ phylum
get_gbif("Satyrium", phylum = "Tracheophyta")
get_gbif("Satyrium", phylum = "Arthropoda")
### w/ phylum & rank
get_gbif("Satyrium", phylum = "Arthropoda", rank = "genus")

## Rank example
get_gbif("Poa", method = "lookup")
get_gbif("Poa", method = "lookup", rank = "genus")
get_gbif("Poa", method = "lookup", family = "Thripidae")

# Fuzzy filter on any filtering fields
## uses grep on the inside
get_gbif("Satyrium", phylum = "arthropoda")
get_gbif("A*", method = "lookup", order = "*tera")
get_gbif("A*", method = "lookup", order = "*ales")

# Convert a gbifid without class information to a gbifid class
as.gbif(get_gbif("Poa annua")) # already a gbifid, returns the same
as.gbif(get_gbif(c("Poa annua","Puma concolor"))) # same
as.gbif(2704179) # numeric
as.gbif(c(2704179,2435099,3171445)) # numeric vector, length > 1
as.gbif("2704179") # character
as.gbif(c("2704179","2435099","3171445")) # character vector, length > 1
as.gbif(list("2704179","2435099","3171445")) # list, either numeric or character
## dont check, much faster
as.gbif("2704179", check=FALSE)
as.gbif(2704179, check=FALSE)
as.gbif(2704179, check=FALSE)
as.gbif(c("2704179","2435099","3171445"), check=FALSE)
as.gbif(list("2704179","2435099","3171445"), check=FALSE)

(out <- as.gbif(c(2704179,2435099,3171445)))
data.frame(out)
as.gbif( data.frame(out) )

# Get all data back
get_gbif_("Puma concolor")
get_gbif_(c("Pinus", "uaudnadndj"))
get_gbif_(c("Pinus", "Puma"), rows=5)
get_gbif_(c("Pinus", "Puma"), rows=1:5)

# use curl options
invisible(get_gbif("Quercus douglasii", verbose = TRUE))
}
}
\seealso{
\code{\link[=classification]{classification()}}

Other taxonomic-ids: 
\code{\link{get_bold}()},
\code{\link{get_eol}()},
\code{\link{get_ids}()},
\code{\link{get_itis}()},
\code{\link{get_iucn}()},
\code{\link{get_natserv}()},
\code{\link{get_nbn}()},
\code{\link{get_ncbi}()},
\code{\link{get_pow}()},
\code{\link{get_tol}()},
\code{\link{get_tps}()},
\code{\link{get_wiki}()},
\code{\link{get_worms}()},
\code{\link{id-accessors}}
}
\author{
Scott Chamberlain, \email{myrmecocystus@gmail.com}
}
\concept{taxonomic-ids}
